//@version=5
strategy("ORB + Key Session Levels Strategy", "ORB Strategy v1.0", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1, commission_type=strategy.commission.percent, commission_value=0.1, slippage=2, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

grpORB = "Opening Range"
showORB = input.bool(true, "Show ORB", group=grpORB)
orbStartTime = input.string("0930", "Start Time (HHMM ET)", tooltip="Enter time in 24hr format. Examples: 0800, 0930, 1400", group=grpORB)
orbDuration = input.string("15 Min", "Duration", options=["5 Min", "15 Min", "30 Min", "1 Hour", "Custom"], group=grpORB)
orbCustomEnd = input.string("0945", "Custom End (HHMM ET)", tooltip="Only used when Duration is 'Custom'", group=grpORB)
showMidline = input.bool(true, "Show Midline", group=grpORB)
orbHistory = input.int(1, "Days to Show", minval=1, maxval=20, group=grpORB)
orbLineWidth = input.int(3, "Line Thickness", minval=1, maxval=5, group=grpORB)
orbHighColor = input.color(color.new(#00d4ff, 0), "High Color", group=grpORB)
orbLowColor = input.color(color.new(#00d4ff, 0), "Low Color", group=grpORB)
orbMidColor = input.color(color.new(#00d4ff, 50), "Midline Color", group=grpORB)

// ── ORB TRADE SIGNALS ──
grpSignals = "ORB Trade Signals"
i_enableSignals = input.bool(true, "Enable Trade Signals", tooltip="Execute trades on ORB break.", group=grpSignals)
i_orbEntryMode = input.string("Breakout", "Entry Mode", options=["Breakout", "Retest Zone", "Retest Midpoint"], tooltip="Breakout: enter on candle close through level.\nRetest Zone: wait for candle to wick back to the broken level and close outside.\nRetest Midpoint: wait for candle to wick back to ORB midpoint and close outside.", group=grpSignals)
i_orbRetestTimeout = input.int(20, "Retest Timeout (bars)", minval=3, maxval=100, tooltip="Max bars to wait for retest after breakout. Resets if no retest. Only used in Retest modes.", group=grpSignals)
i_orbSLMethod = input.string("Midpoint", "Stop Loss", options=["Midpoint", "Opposite Side", "Fixed Points"], tooltip="Midpoint: SL at middle of ORB range.\nOpposite Side: SL at ORB low (long) / ORB high (short).\nFixed Points: user-defined distance from entry.", group=grpSignals)
i_orbSLPoints = input.float(20.0, "SL Fixed Points", minval=0.25, step=0.25, tooltip="Only used when SL = Fixed Points.", group=grpSignals)
i_orbContracts = input.int(3, "Total Contracts", minval=1, maxval=1000, tooltip="Total position size in contracts/shares.", group=grpSignals)
i_orbTP1RR = input.float(1.0, "TP1 R:R", minval=0.1, step=0.1, group=grpSignals, inline="tp1")
i_orbTP1Qty = input.int(1, "Close Qty", minval=0, maxval=1000, tooltip="Contracts/shares to close at TP1.", group=grpSignals, inline="tp1")
i_orbTP2RR = input.float(2.0, "TP2 R:R", minval=0.1, step=0.1, group=grpSignals, inline="tp2")
i_orbTP2Qty = input.int(1, "Close Qty", minval=0, maxval=1000, tooltip="Contracts/shares to close at TP2.", group=grpSignals, inline="tp2")
i_orbTP3RR = input.float(3.0, "TP3 R:R", minval=0.1, step=0.1, group=grpSignals, inline="tp3")
i_orbTP3Qty = input.int(0, "Close Qty", minval=0, maxval=1000, tooltip="Contracts/shares to close at TP3. Set 0 to close all remaining.", group=grpSignals, inline="tp3")
i_orbMoveToBE = input.bool(true, "Move SL to BE after TP1", tooltip="Automatically move stop loss to break-even (entry price) after TP1 is hit.", group=grpSignals)
i_orbShowSLTP = input.bool(true, "Show SL/TP Lines", group=grpSignals)
i_orbShowEntry = input.bool(true, "Show Entry Arrows", group=grpSignals)

grpSessions = "Session Mode"
sessionMode = input.string("Full Sessions", "Mode", options=["Kill Zones", "Full Sessions"], tooltip="Kill Zones: Non-overlapping high-activity windows\nFull Sessions: Traditional full session times", group=grpSessions)

grpPD = "Previous Day"
showPDHL = input.bool(true, "Show PDH/PDL", group=grpPD)
pdSource = input.string("RTH Only", "PDH/PDL Source", options=["RTH Only", "Full Session (Futures)"], tooltip="RTH Only: 9:30 AM - 4:00 PM ET (cash market hours)\nFull Session: 6:00 PM - 5:00 PM ET (futures 23hr session)", group=grpPD)
rthStart = input.string("0930", "RTH Start (HHMM ET)", tooltip="Regular Trading Hours start - used when Source = RTH Only", group=grpPD)
rthEnd = input.string("1600", "RTH End (HHMM ET)", tooltip="Regular Trading Hours end - used when Source = RTH Only", group=grpPD)
fullSessionStart = input.string("1800", "Full Session Start (HHMM ET)", tooltip="Futures session start (previous day 6pm) - used when Source = Full Session", group=grpPD)
fullSessionEnd = input.string("1700", "Full Session End (HHMM ET)", tooltip="Futures session end (5pm) - used when Source = Full Session", group=grpPD)
pdHistory = input.int(1, "Days to Show", minval=0, maxval=10, group=grpPD)
pdLineWidth = input.int(1, "Line Thickness", minval=1, maxval=5, group=grpPD)
pdhColor = input.color(color.new(color.yellow, 0), "Color", group=grpPD)

grpAsian = "Asian Session"
showAsian = input.bool(true, "Show Asian H/L", group=grpAsian)
showAsianBox = input.bool(false, "Show Session Box", tooltip="Draw a box around the Asian session range", group=grpAsian)
showAsianMid = input.bool(false, "Show Midline", group=grpAsian)
extendAsianLines = input.bool(true, "Extend Lines", tooltip="Extend Asian H/L lines beyond session end", group=grpAsian)
asianExtendUntil = input.string("1130", "Extend Until (HHMM ET)", tooltip="Time to extend lines until when 'Extend Lines' is enabled", group=grpAsian)
asianStartKZ = input.string("2000", "Kill Zone Start (HHMM ET)", group=grpAsian)
asianEndKZ = input.string("0000", "Kill Zone End (HHMM ET)", group=grpAsian)
asianStartFull = input.string("1800", "Full Session Start (HHMM ET)", group=grpAsian)
asianEndFull = input.string("0300", "Full Session End (HHMM ET)", group=grpAsian)
asianHistory = input.int(1, "Days to Show", minval=0, maxval=10, group=grpAsian)
asianLineWidth = input.int(1, "Line Thickness", minval=1, maxval=5, group=grpAsian)
asianColor = input.color(color.new(color.purple, 0), "Color", group=grpAsian)
asianBoxColor = input.color(color.new(color.purple, 90), "Box Fill Color", group=grpAsian)

grpLondon = "London Session"
showLondon = input.bool(true, "Show London H/L", group=grpLondon)
showLondonBox = input.bool(false, "Show Session Box", tooltip="Draw a box around the London session range", group=grpLondon)
showLondonMid = input.bool(false, "Show Midline", group=grpLondon)
extendLondonLines = input.bool(true, "Extend Lines", tooltip="Extend London H/L lines beyond session end", group=grpLondon)
londonExtendUntil = input.string("1130", "Extend Until (HHMM ET)", tooltip="Time to extend lines until when 'Extend Lines' is enabled", group=grpLondon)
londonStartKZ = input.string("0200", "Kill Zone Start (HHMM ET)", group=grpLondon)
londonEndKZ = input.string("0500", "Kill Zone End (HHMM ET)", group=grpLondon)
londonStartFull = input.string("0300", "Full Session Start (HHMM ET)", group=grpLondon)
londonEndFull = input.string("0930", "Full Session End (HHMM ET)", tooltip="Ends when NY opens to avoid overlap", group=grpLondon)
londonHistory = input.int(1, "Days to Show", minval=0, maxval=10, group=grpLondon)
londonLineWidth = input.int(1, "Line Thickness", minval=1, maxval=5, group=grpLondon)
londonColor = input.color(color.new(color.orange, 0), "Color", group=grpLondon)
londonBoxColor = input.color(color.new(color.orange, 90), "Box Fill Color", group=grpLondon)

grpFVG = "Fair Value Gaps"
showFVG = input.bool(true, "Show FVGs", group=grpFVG)
fvgThreshold = input.float(0, "Threshold %", minval=0, maxval=5, step=0.1, group=grpFVG)
autoThreshold = input.bool(true, "Auto Threshold", group=grpFVG)
fvgExtend = input.int(50, "Extend Bars", minval=10, maxval=200, group=grpFVG)
fvgMitigation = input.bool(true, "Remove When Mitigated", group=grpFVG)
bullFVGColor = input.color(color.new(#089981, 70), "Bullish FVG", group=grpFVG)
bearFVGColor = input.color(color.new(#f23645, 70), "Bearish FVG", group=grpFVG)

grpHTF = "Higher Timeframe Bias"
showDashboard = input.bool(true, "Show Dashboard", group=grpHTF)
htf1 = input.timeframe("240", "Timeframe 1", group=grpHTF)
htf2 = input.timeframe("60", "Timeframe 2", group=grpHTF)
swingLookback = input.int(10, "Swing Lookback", minval=3, maxval=50, group=grpHTF)
dashPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=grpHTF)
dashSize = input.string("Tiny", "Dashboard Size", options=["Tiny", "Small", "Normal"], group=grpHTF)

grpDashColors = "Dashboard Colors"
dashBgColor = input.color(color.new(#0d1117, 10), "Background", group=grpDashColors)
dashBorderColor = input.color(color.new(color.gray, 70), "Border", group=grpDashColors)
dashHeaderBg = input.color(color.new(#2962ff, 70), "Header Background", group=grpDashColors)
dashHeaderText = input.color(color.white, "Header Text", group=grpDashColors)
dashLabelColor = input.color(color.gray, "Labels", group=grpDashColors)
dashBullColor = input.color(color.green, "Bullish", group=grpDashColors)
dashBearColor = input.color(color.red, "Bearish", group=grpDashColors)
dashNeutralColor = input.color(color.gray, "Neutral", group=grpDashColors)

grpStyle = "Style"
lineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group=grpStyle)
showLabels = input.bool(true, "Show Labels", group=grpStyle)
labelSize = input.string("Tiny", "Label Size", options=["Tiny", "Small", "Normal"], group=grpStyle)

// ══════════════════════════════════════════════════════════════════════════════
// SESSION TIME CALCULATION
// ══════════════════════════════════════════════════════════════════════════════

calcEndTime(simple string startTime, simple string duration) =>
    startHour = math.floor(str.tonumber(str.substring(startTime, 0, 2)))
    startMin = math.floor(str.tonumber(str.substring(startTime, 2, 4)))
    addMins = switch duration
        "5 Min" => 5
        "15 Min" => 15
        "30 Min" => 30
        "1 Hour" => 60
        => 0
    totalMins = startMin + addMins
    endHour = startHour + math.floor(totalMins / 60)
    endMin = totalMins % 60
    endHourStr = endHour < 10 ? "0" + str.tostring(endHour) : str.tostring(endHour)
    endMinStr = endMin < 10 ? "0" + str.tostring(endMin) : str.tostring(endMin)
    endHourStr + endMinStr

// Build session strings based on mode
orbEndTime = orbDuration == "Custom" ? orbCustomEnd : calcEndTime(orbStartTime, orbDuration)
orbSession = orbStartTime + "-" + orbEndTime
pdSession = pdSource == "RTH Only" ? rthStart + "-" + rthEnd : fullSessionStart + "-" + fullSessionEnd
asianSession = sessionMode == "Kill Zones" ? asianStartKZ + "-" + asianEndKZ : asianStartFull + "-" + asianEndFull
londonSession = sessionMode == "Kill Zones" ? londonStartKZ + "-" + londonEndKZ : londonStartFull + "-" + londonEndFull
asianEnd = sessionMode == "Kill Zones" ? asianEndKZ : asianEndFull
londonEnd = sessionMode == "Kill Zones" ? londonEndKZ : londonEndFull
asianExtendSession = asianEnd + "-" + asianExtendUntil
londonExtendSession = londonEnd + "-" + londonExtendUntil
orbDisplayTime = orbDuration == "Custom" ? orbStartTime + "-" + orbCustomEnd : orbStartTime + " " + orbDuration

// ══════════════════════════════════════════════════════════════════════════════
// HELPERS
// ══════════════════════════════════════════════════════════════════════════════

getLineStyle() =>
    switch lineStyle
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted

getLabelSize() =>
    switch labelSize
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal

getDashSize() =>
    switch dashSize
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal

formatTF(simple string tf) =>
    switch tf
        "1" => "1m"
        "3" => "3m"
        "5" => "5m"
        "15" => "15m"
        "30" => "30m"
        "45" => "45m"
        "60" => "1H"
        "120" => "2H"
        "180" => "3H"
        "240" => "4H"
        "D" => "1D"
        "W" => "1W"
        => tf

// ══════════════════════════════════════════════════════════════════════════════
// TYPES
// ══════════════════════════════════════════════════════════════════════════════

type orbData
    float hi
    float lo
    float mid
    int startBar
    int hiBar
    int loBar
    line hiLine
    line loLine
    line midLine
    label hiLabel
    label loLabel
    label midLabel

type levelData
    float hi
    float lo
    float mid
    int startBar
    int hiBar
    int loBar
    line hiLine
    line loLine
    line midLine
    label hiLabel
    label loLabel
    label midLabel
    box sessionBox

type fvgData
    float top
    float bottom
    bool isBull
    int barIdx
    box area

// ══════════════════════════════════════════════════════════════════════════════
// VARIABLES
// ══════════════════════════════════════════════════════════════════════════════

var orbData[] orbArray = array.new<orbData>(0)
var levelData[] pdArray = array.new<levelData>(0)
var levelData[] asianArray = array.new<levelData>(0)
var levelData[] londonArray = array.new<levelData>(0)
var fvgData[] fvgArray = array.new<fvgData>(0)

// ORB tracking
var float currentORBHigh = na
var float currentORBLow = na
var float currentORBMid = na
var int orbStartBar = na
var int orbHighBar = na
var int orbLowBar = na
var bool orbBuilding = false
var bool orbComplete = false

// ORB Trade Signal tracking
var bool orbSignalFired = false
var bool orbBreakoutPending = false
var int orbBreakoutDir = 0
var int orbBreakoutBar = 0
var float orbSignalEntry = na
var float orbSignalSL = na
var float orbSignalTP1 = na
var float orbSignalTP2 = na
var float orbSignalTP3 = na
var int orbSignalDir = 0
var bool orbMovedToBE = false
var line orbSLLine = na
var line orbTP1Line = na
var line orbTP2Line = na
var line orbTP3Line = na
var label orbSLLabel = na
var label orbTP1Label = na
var label orbTP2Label = na
var label orbTP3Label = na

// PDH/PDL tracking
var float pdTrackHigh = na
var float pdTrackLow = na
var float currentPDH = na
var float currentPDL = na

// Asian tracking
var float asianHigh = na
var float asianLow = na
var int asianHighBar = na
var int asianLowBar = na
var int asianStartBar = na
var bool asianBuilding = false
var float currentAsianHigh = na
var float currentAsianLow = na
var float currentAsianMid = na
var box currentAsianBox = na

// London tracking
var float londonHigh = na
var float londonLow = na
var int londonHighBar = na
var int londonLowBar = na
var int londonStartBar = na
var bool londonBuilding = false
var float currentLondonHigh = na
var float currentLondonLow = na
var float currentLondonMid = na
var box currentLondonBox = na

var string htf1PrevBias = ""
var string htf2PrevBias = ""

// ══════════════════════════════════════════════════════════════════════════════
// TIME HELPERS
// ══════════════════════════════════════════════════════════════════════════════

newDay = dayofweek != dayofweek[1]
inORBSession = not na(time(timeframe.period, orbSession, "America/New_York"))
inPDSession = not na(time(timeframe.period, pdSession, "America/New_York"))
inAsianSession = not na(time(timeframe.period, asianSession, "America/New_York"))
inLondonSession = not na(time(timeframe.period, londonSession, "America/New_York"))
inAsianExtend = extendAsianLines and not na(time(timeframe.period, asianExtendSession, "America/New_York"))
inLondonExtend = extendLondonLines and not na(time(timeframe.period, londonExtendSession, "America/New_York"))

// ══════════════════════════════════════════════════════════════════════════════
// HIGHER TIMEFRAME BIAS ANALYSIS
// ══════════════════════════════════════════════════════════════════════════════

[htf1High, htf1Low] = request.security(syminfo.tickerid, htf1, [high, low])
htf1SwingHigh = ta.pivothigh(htf1High, swingLookback, swingLookback)
htf1SwingLow = ta.pivotlow(htf1Low, swingLookback, swingLookback)

var float htf1LastHigh = na
var float htf1PrevHigh = na
var float htf1LastLow = na
var float htf1PrevLow = na

if not na(htf1SwingHigh)
    htf1PrevHigh := htf1LastHigh
    htf1LastHigh := htf1SwingHigh
if not na(htf1SwingLow)
    htf1PrevLow := htf1LastLow
    htf1LastLow := htf1SwingLow

htf1HigherHigh = not na(htf1LastHigh) and not na(htf1PrevHigh) and htf1LastHigh > htf1PrevHigh
htf1LowerHigh = not na(htf1LastHigh) and not na(htf1PrevHigh) and htf1LastHigh < htf1PrevHigh
htf1HigherLow = not na(htf1LastLow) and not na(htf1PrevLow) and htf1LastLow > htf1PrevLow
htf1LowerLow = not na(htf1LastLow) and not na(htf1PrevLow) and htf1LastLow < htf1PrevLow

htf1Bullish = htf1HigherHigh and htf1HigherLow
htf1Bearish = htf1LowerHigh and htf1LowerLow
htf1BiasText = htf1Bullish ? "BULLISH" : htf1Bearish ? "BEARISH" : "NEUTRAL"
htf1BiasColor = htf1Bullish ? dashBullColor : htf1Bearish ? dashBearColor : dashNeutralColor
htf1StructureText = (htf1HigherHigh ? "HH" : htf1LowerHigh ? "LH" : "-") + " / " + (htf1HigherLow ? "HL" : htf1LowerLow ? "LL" : "-")
htf1BiasChanged = htf1BiasText != htf1PrevBias and htf1PrevBias != ""
htf1PrevBias := htf1BiasText

[htf2High, htf2Low] = request.security(syminfo.tickerid, htf2, [high, low])
htf2SwingHigh = ta.pivothigh(htf2High, swingLookback, swingLookback)
htf2SwingLow = ta.pivotlow(htf2Low, swingLookback, swingLookback)

var float htf2LastHigh = na
var float htf2PrevHigh = na
var float htf2LastLow = na
var float htf2PrevLow = na

if not na(htf2SwingHigh)
    htf2PrevHigh := htf2LastHigh
    htf2LastHigh := htf2SwingHigh
if not na(htf2SwingLow)
    htf2PrevLow := htf2LastLow
    htf2LastLow := htf2SwingLow

htf2HigherHigh = not na(htf2LastHigh) and not na(htf2PrevHigh) and htf2LastHigh > htf2PrevHigh
htf2LowerHigh = not na(htf2LastHigh) and not na(htf2PrevHigh) and htf2LastHigh < htf2PrevHigh
htf2HigherLow = not na(htf2LastLow) and not na(htf2PrevLow) and htf2LastLow > htf2PrevLow
htf2LowerLow = not na(htf2LastLow) and not na(htf2PrevLow) and htf2LastLow < htf2PrevLow

htf2Bullish = htf2HigherHigh and htf2HigherLow
htf2Bearish = htf2LowerHigh and htf2LowerLow
htf2BiasText = htf2Bullish ? "BULLISH" : htf2Bearish ? "BEARISH" : "NEUTRAL"
htf2BiasColor = htf2Bullish ? dashBullColor : htf2Bearish ? dashBearColor : dashNeutralColor
htf2StructureText = (htf2HigherHigh ? "HH" : htf2LowerHigh ? "LH" : "-") + " / " + (htf2HigherLow ? "HL" : htf2LowerLow ? "LL" : "-")
htf2BiasChanged = htf2BiasText != htf2PrevBias and htf2PrevBias != ""
htf2PrevBias := htf2BiasText

// ══════════════════════════════════════════════════════════════════════════════
// ORB TRACKING
// ══════════════════════════════════════════════════════════════════════════════

if newDay
    currentORBHigh := na
    currentORBLow := na
    currentORBMid := na
    orbBuilding := false
    orbComplete := false
    orbStartBar := na
    orbHighBar := na
    orbLowBar := na
    orbSignalFired := false
    orbBreakoutPending := false
    orbBreakoutDir := 0
    orbBreakoutBar := 0
    orbSignalDir := 0
    orbMovedToBE := false
    orbSignalEntry := na
    orbSignalSL := na
    orbSignalTP1 := na
    orbSignalTP2 := na
    orbSignalTP3 := na
    line.delete(orbSLLine)
    line.delete(orbTP1Line)
    line.delete(orbTP2Line)
    line.delete(orbTP3Line)
    label.delete(orbSLLabel)
    label.delete(orbTP1Label)
    label.delete(orbTP2Label)
    label.delete(orbTP3Label)

if inORBSession and not orbComplete
    if not orbBuilding
        orbStartBar := bar_index
        orbBuilding := true
    if na(currentORBHigh) or high > currentORBHigh
        currentORBHigh := high
        orbHighBar := bar_index
    if na(currentORBLow) or low < currentORBLow
        currentORBLow := low
        orbLowBar := bar_index

if not inORBSession and orbBuilding and not orbComplete and not na(currentORBHigh)
    orbComplete := true
    currentORBMid := (currentORBHigh + currentORBLow) / 2

    if showORB
        hiLine = line.new(orbHighBar, currentORBHigh, bar_index + 100, currentORBHigh, color=orbHighColor, style=getLineStyle(), width=orbLineWidth)
        loLine = line.new(orbLowBar, currentORBLow, bar_index + 100, currentORBLow, color=orbLowColor, style=getLineStyle(), width=orbLineWidth)
        midLine = showMidline ? line.new(orbStartBar, currentORBMid, bar_index + 100, currentORBMid, color=orbMidColor, style=line.style_dotted, width=math.max(1, orbLineWidth - 1)) : na
        hiLabel = showLabels ? label.new(bar_index + 102, currentORBHigh, "ORB H", style=label.style_none, textcolor=orbHighColor, size=getLabelSize()) : na
        loLabel = showLabels ? label.new(bar_index + 102, currentORBLow, "ORB L", style=label.style_none, textcolor=orbLowColor, size=getLabelSize()) : na
        midLabel = showLabels and showMidline ? label.new(bar_index + 102, currentORBMid, "ORB M", style=label.style_none, textcolor=orbMidColor, size=getLabelSize()) : na

        newOrb = orbData.new(currentORBHigh, currentORBLow, currentORBMid, orbStartBar, orbHighBar, orbLowBar, hiLine, loLine, midLine, hiLabel, loLabel, midLabel)
        array.unshift(orbArray, newOrb)

        if array.size(orbArray) > orbHistory
            old = array.pop(orbArray)
            line.delete(old.hiLine)
            line.delete(old.loLine)
            line.delete(old.midLine)
            label.delete(old.hiLabel)
            label.delete(old.loLabel)
            label.delete(old.midLabel)

    if orbComplete and array.size(orbArray) > 0
        current = array.get(orbArray, 0)
        line.set_x2(current.hiLine, bar_index + 20)
        line.set_x2(current.loLine, bar_index + 20)
        if showMidline and not na(current.midLine)
            line.set_x2(current.midLine, bar_index + 20)
        if showLabels
            label.set_x(current.hiLabel, bar_index + 22)
            label.set_x(current.loLabel, bar_index + 22)
            if showMidline and not na(current.midLabel)
                label.set_x(current.midLabel, bar_index + 22)

orbHighBreak = orbComplete and ta.crossover(close, currentORBHigh)
orbLowBreak = orbComplete and ta.crossunder(close, currentORBLow)

// ══════════════════════════════════════════════════════════════════════════════
// ORB TRADE SIGNALS — Breakout / Retest Zone / Retest Midpoint
// ══════════════════════════════════════════════════════════════════════════════

bool orbLongSignal = false
bool orbShortSignal = false

// Phase 1: Check retest / invalidation
if i_enableSignals and orbBreakoutPending and bar_index > orbBreakoutBar and not orbSignalFired
    _retestLvl = i_orbEntryMode == "Retest Midpoint" ? currentORBMid : (orbBreakoutDir == 1 ? currentORBHigh : currentORBLow)
    if orbBreakoutDir == 1
        if low <= _retestLvl and close > currentORBHigh
            orbLongSignal := true
            orbBreakoutPending := false
        else if close <= currentORBHigh
            orbBreakoutPending := false
    else if orbBreakoutDir == -1
        if high >= _retestLvl and close < currentORBLow
            orbShortSignal := true
            orbBreakoutPending := false
        else if close >= currentORBLow
            orbBreakoutPending := false

    if orbBreakoutPending and bar_index - orbBreakoutBar >= i_orbRetestTimeout
        orbBreakoutPending := false

// Phase 2: Detect breakout
if i_enableSignals and orbComplete and not orbSignalFired
    if orbHighBreak and not orbBreakoutPending
        if i_orbEntryMode == "Breakout"
            orbLongSignal := true
        else
            orbBreakoutPending := true
            orbBreakoutDir := 1
            orbBreakoutBar := bar_index
    else if orbLowBreak and not orbBreakoutPending
        if i_orbEntryMode == "Breakout"
            orbShortSignal := true
        else
            orbBreakoutPending := true
            orbBreakoutDir := -1
            orbBreakoutBar := bar_index

// Execute LONG entry
if orbLongSignal
    orbSignalFired := true
    orbSignalEntry := close
    orbSignalDir := 1
    if i_orbSLMethod == "Midpoint"
        orbSignalSL := currentORBMid
    else if i_orbSLMethod == "Opposite Side"
        orbSignalSL := currentORBLow
    else
        orbSignalSL := close - i_orbSLPoints
    _risk = math.abs(orbSignalEntry - orbSignalSL)
    if _risk > 0
        orbSignalTP1 := orbSignalEntry + _risk * i_orbTP1RR
        orbSignalTP2 := orbSignalEntry + _risk * i_orbTP2RR
        orbSignalTP3 := orbSignalEntry + _risk * i_orbTP3RR
    // Execute strategy entry
    strategy.entry("ORB Long", strategy.long, qty=i_orbContracts, comment="ORB Long")
    if i_orbShowSLTP
        line.delete(orbSLLine)
        line.delete(orbTP1Line)
        line.delete(orbTP2Line)
        line.delete(orbTP3Line)
        label.delete(orbSLLabel)
        label.delete(orbTP1Label)
        label.delete(orbTP2Label)
        label.delete(orbTP3Label)
        orbSLLine := line.new(bar_index, orbSignalSL, bar_index + 30, orbSignalSL, color=color.red, style=line.style_dashed, width=1)
        orbTP1Line := line.new(bar_index, orbSignalTP1, bar_index + 30, orbSignalTP1, color=color.lime, style=line.style_dashed, width=1)
        orbTP2Line := line.new(bar_index, orbSignalTP2, bar_index + 30, orbSignalTP2, color=color.green, style=line.style_dashed, width=1)
        orbTP3Line := line.new(bar_index, orbSignalTP3, bar_index + 30, orbSignalTP3, color=color.teal, style=line.style_dashed, width=1)
        if showLabels
            orbSLLabel := label.new(bar_index + 32, orbSignalSL, "SL", style=label.style_none, textcolor=color.red, size=getLabelSize())
            orbTP1Label := label.new(bar_index + 32, orbSignalTP1, "TP1", style=label.style_none, textcolor=color.lime, size=getLabelSize())
            orbTP2Label := label.new(bar_index + 32, orbSignalTP2, "TP2", style=label.style_none, textcolor=color.green, size=getLabelSize())
            orbTP3Label := label.new(bar_index + 32, orbSignalTP3, "TP3", style=label.style_none, textcolor=color.teal, size=getLabelSize())

// Execute SHORT entry
if orbShortSignal
    orbSignalFired := true
    orbSignalEntry := close
    orbSignalDir := -1
    if i_orbSLMethod == "Midpoint"
        orbSignalSL := currentORBMid
    else if i_orbSLMethod == "Opposite Side"
        orbSignalSL := currentORBHigh
    else
        orbSignalSL := close + i_orbSLPoints
    _risk = math.abs(orbSignalSL - orbSignalEntry)
    if _risk > 0
        orbSignalTP1 := orbSignalEntry - _risk * i_orbTP1RR
        orbSignalTP2 := orbSignalEntry - _risk * i_orbTP2RR
        orbSignalTP3 := orbSignalEntry - _risk * i_orbTP3RR
    // Execute strategy entry
    strategy.entry("ORB Short", strategy.short, qty=i_orbContracts, comment="ORB Short")
    if i_orbShowSLTP
        line.delete(orbSLLine)
        line.delete(orbTP1Line)
        line.delete(orbTP2Line)
        line.delete(orbTP3Line)
        label.delete(orbSLLabel)
        label.delete(orbTP1Label)
        label.delete(orbTP2Label)
        label.delete(orbTP3Label)
        orbSLLine := line.new(bar_index, orbSignalSL, bar_index + 30, orbSignalSL, color=color.red, style=line.style_dashed, width=1)
        orbTP1Line := line.new(bar_index, orbSignalTP1, bar_index + 30, orbSignalTP1, color=color.lime, style=line.style_dashed, width=1)
        orbTP2Line := line.new(bar_index, orbSignalTP2, bar_index + 30, orbSignalTP2, color=color.green, style=line.style_dashed, width=1)
        orbTP3Line := line.new(bar_index, orbSignalTP3, bar_index + 30, orbSignalTP3, color=color.teal, style=line.style_dashed, width=1)
        if showLabels
            orbSLLabel := label.new(bar_index + 32, orbSignalSL, "SL", style=label.style_none, textcolor=color.red, size=getLabelSize())
            orbTP1Label := label.new(bar_index + 32, orbSignalTP1, "TP1", style=label.style_none, textcolor=color.lime, size=getLabelSize())
            orbTP2Label := label.new(bar_index + 32, orbSignalTP2, "TP2", style=label.style_none, textcolor=color.green, size=getLabelSize())
            orbTP3Label := label.new(bar_index + 32, orbSignalTP3, "TP3", style=label.style_none, textcolor=color.teal, size=getLabelSize())

// Extend SL/TP lines forward each bar
if orbSignalDir != 0 and i_orbShowSLTP
    if not na(orbSLLine)
        line.set_x2(orbSLLine, bar_index + 20)
        line.set_x2(orbTP1Line, bar_index + 20)
        line.set_x2(orbTP2Line, bar_index + 20)
        line.set_x2(orbTP3Line, bar_index + 20)
    if showLabels and not na(orbSLLabel)
        label.set_x(orbSLLabel, bar_index + 22)
        label.set_x(orbTP1Label, bar_index + 22)
        label.set_x(orbTP2Label, bar_index + 22)
        label.set_x(orbTP3Label, bar_index + 22)

// Entry arrows
plotshape(i_orbShowEntry and orbLongSignal, title="ORB Long", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, text="ORB LONG")
plotshape(i_orbShowEntry and orbShortSignal, title="ORB Short", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text="ORB SHORT")

// ══════════════════════════════════════════════════════════════════════════════
// ORB EXIT MANAGEMENT — strategy exits with partial closes
// ══════════════════════════════════════════════════════════════════════════════

if i_enableSignals and strategy.position_size != 0
    // Move SL to break-even after TP1 is hit
    if i_orbMoveToBE and not orbMovedToBE and not na(orbSignalEntry)
        if strategy.position_size > 0 and high >= orbSignalTP1
            orbSignalSL := orbSignalEntry
            orbMovedToBE := true
            // Update SL line visually
            if i_orbShowSLTP and not na(orbSLLine)
                line.delete(orbSLLine)
                orbSLLine := line.new(bar_index, orbSignalSL, bar_index + 30, orbSignalSL, color=color.orange, style=line.style_dashed, width=1)
            if showLabels and not na(orbSLLabel)
                label.delete(orbSLLabel)
                orbSLLabel := label.new(bar_index + 32, orbSignalSL, "BE", style=label.style_none, textcolor=color.orange, size=getLabelSize())
        else if strategy.position_size < 0 and low <= orbSignalTP1
            orbSignalSL := orbSignalEntry
            orbMovedToBE := true
            // Update SL line visually
            if i_orbShowSLTP and not na(orbSLLine)
                line.delete(orbSLLine)
                orbSLLine := line.new(bar_index, orbSignalSL, bar_index + 30, orbSignalSL, color=color.orange, style=line.style_dashed, width=1)
            if showLabels and not na(orbSLLabel)
                label.delete(orbSLLabel)
                orbSLLabel := label.new(bar_index + 32, orbSignalSL, "BE", style=label.style_none, textcolor=color.orange, size=getLabelSize())

    if strategy.position_size > 0  // LONG position
        // Stop loss for full position
        strategy.exit("SL Long", "ORB Long", stop=orbSignalSL)
        // Take profit levels with partial closes
        if i_orbTP1Qty > 0
            strategy.exit("TP1 Long", "ORB Long", limit=orbSignalTP1, qty=i_orbTP1Qty)
        if i_orbTP2Qty > 0
            strategy.exit("TP2 Long", "ORB Long", limit=orbSignalTP2, qty=i_orbTP2Qty)
        // TP3 closes remaining position (if qty specified) or acts as final exit
        if i_orbTP3Qty > 0
            strategy.exit("TP3 Long", "ORB Long", limit=orbSignalTP3, qty=i_orbTP3Qty)
        else
            strategy.exit("TP3 Long", "ORB Long", limit=orbSignalTP3)
    else if strategy.position_size < 0  // SHORT position
        // Stop loss for full position
        strategy.exit("SL Short", "ORB Short", stop=orbSignalSL)
        // Take profit levels with partial closes
        if i_orbTP1Qty > 0
            strategy.exit("TP1 Short", "ORB Short", limit=orbSignalTP1, qty=i_orbTP1Qty)
        if i_orbTP2Qty > 0
            strategy.exit("TP2 Short", "ORB Short", limit=orbSignalTP2, qty=i_orbTP2Qty)
        // TP3 closes remaining position (if qty specified) or acts as final exit
        if i_orbTP3Qty > 0
            strategy.exit("TP3 Short", "ORB Short", limit=orbSignalTP3, qty=i_orbTP3Qty)
        else
            strategy.exit("TP3 Short", "ORB Short", limit=orbSignalTP3)

// ══════════════════════════════════════════════════════════════════════════════
// PREVIOUS DAY HIGH/LOW
// ══════════════════════════════════════════════════════════════════════════════

if newDay
    if showPDHL and pdHistory > 0 and not na(pdTrackHigh)
        currentPDH := pdTrackHigh
        currentPDL := pdTrackLow
        hiLine = line.new(bar_index, pdTrackHigh, bar_index + 100, pdTrackHigh, color=pdhColor, style=getLineStyle(), width=pdLineWidth)
        loLine = line.new(bar_index, pdTrackLow, bar_index + 100, pdTrackLow, color=pdhColor, style=getLineStyle(), width=pdLineWidth)
        hiLabel = showLabels ? label.new(bar_index + 102, pdTrackHigh, "PDH", style=label.style_none, textcolor=pdhColor, size=getLabelSize()) : na
        loLabel = showLabels ? label.new(bar_index + 102, pdTrackLow, "PDL", style=label.style_none, textcolor=pdhColor, size=getLabelSize()) : na
        newLevel = levelData.new(pdTrackHigh, pdTrackLow, na, na, bar_index, bar_index, hiLine, loLine, na, hiLabel, loLabel, na, na)
        array.unshift(pdArray, newLevel)
        if array.size(pdArray) > pdHistory
            old = array.pop(pdArray)
            line.delete(old.hiLine)
            line.delete(old.loLine)
            label.delete(old.hiLabel)
            label.delete(old.loLabel)
        pdTrackHigh := na
        pdTrackLow := na

if inPDSession
    if na(pdTrackHigh) or high > pdTrackHigh
        pdTrackHigh := high
    if na(pdTrackLow) or low < pdTrackLow
        pdTrackLow := low

if array.size(pdArray) > 0
    for i = 0 to array.size(pdArray) - 1
        lvl = array.get(pdArray, i)
        line.set_x2(lvl.hiLine, bar_index + 20)
        line.set_x2(lvl.loLine, bar_index + 20)
        if i == 0 and showLabels
            label.set_x(lvl.hiLabel, bar_index + 22)
            label.set_x(lvl.loLabel, bar_index + 22)
        else
            label.delete(lvl.hiLabel)
            label.delete(lvl.loLabel)
            lvl.hiLabel := na
            lvl.loLabel := na

// ══════════════════════════════════════════════════════════════════════════════
// ASIAN SESSION
// ══════════════════════════════════════════════════════════════════════════════

if inAsianSession
    if not inAsianSession[1]
        asianHigh := high
        asianLow := low
        asianHighBar := bar_index
        asianLowBar := bar_index
        asianStartBar := bar_index
        asianBuilding := true
        if showAsianBox and showAsian
            box.delete(currentAsianBox)
            currentAsianBox := box.new(bar_index, high, bar_index, low, border_color=asianColor, bgcolor=asianBoxColor, border_width=1)
    else
        if high > asianHigh
            asianHigh := high
            asianHighBar := bar_index
        if low < asianLow
            asianLow := low
            asianLowBar := bar_index
        if showAsianBox and showAsian and not na(currentAsianBox)
            box.set_top(currentAsianBox, asianHigh)
            box.set_bottom(currentAsianBox, asianLow)
            box.set_right(currentAsianBox, bar_index)

if not inAsianSession and inAsianSession[1] and asianBuilding
    asianBuilding := false
    currentAsianHigh := asianHigh
    currentAsianLow := asianLow
    currentAsianMid := (asianHigh + asianLow) / 2
    if showAsian and asianHistory > 0 and not na(asianHigh)
        hiLine = line.new(asianHighBar, asianHigh, bar_index + 100, asianHigh, color=asianColor, style=getLineStyle(), width=asianLineWidth)
        loLine = line.new(asianLowBar, asianLow, bar_index + 100, asianLow, color=asianColor, style=getLineStyle(), width=asianLineWidth)
        midLine = showAsianMid ? line.new(asianStartBar, currentAsianMid, bar_index + 100, currentAsianMid, color=color.new(asianColor, 50), style=line.style_dotted, width=math.max(1, asianLineWidth - 1)) : na
        hiLabel = showLabels ? label.new(bar_index + 102, asianHigh, "ASIA H", style=label.style_none, textcolor=asianColor, size=getLabelSize()) : na
        loLabel = showLabels ? label.new(bar_index + 102, asianLow, "ASIA L", style=label.style_none, textcolor=asianColor, size=getLabelSize()) : na
        midLabel = showLabels and showAsianMid ? label.new(bar_index + 102, currentAsianMid, "ASIA M", style=label.style_none, textcolor=color.new(asianColor, 50), size=getLabelSize()) : na
        newLevel = levelData.new(asianHigh, asianLow, currentAsianMid, asianStartBar, asianHighBar, asianLowBar, hiLine, loLine, midLine, hiLabel, loLabel, midLabel, currentAsianBox)
        array.unshift(asianArray, newLevel)
        if array.size(asianArray) > asianHistory
            old = array.pop(asianArray)
            line.delete(old.hiLine)
            line.delete(old.loLine)
            line.delete(old.midLine)
            label.delete(old.hiLabel)
            label.delete(old.loLabel)
            label.delete(old.midLabel)
            box.delete(old.sessionBox)

if array.size(asianArray) > 0
    for i = 0 to array.size(asianArray) - 1
        lvl = array.get(asianArray, i)
        extendBars = bar_index + 20
        line.set_x2(lvl.hiLine, extendBars)
        line.set_x2(lvl.loLine, extendBars)
        if showAsianMid and not na(lvl.midLine)
            line.set_x2(lvl.midLine, extendBars)
        if i == 0 and showLabels
            label.set_x(lvl.hiLabel, extendBars + 2)
            label.set_x(lvl.loLabel, extendBars + 2)
            if showAsianMid and not na(lvl.midLabel)
                label.set_x(lvl.midLabel, extendBars + 2)
        else
            label.delete(lvl.hiLabel)
            label.delete(lvl.loLabel)
            label.delete(lvl.midLabel)
            lvl.hiLabel := na
            lvl.loLabel := na
            lvl.midLabel := na

// ══════════════════════════════════════════════════════════════════════════════
// LONDON SESSION
// ══════════════════════════════════════════════════════════════════════════════

if inLondonSession
    if not inLondonSession[1]
        londonHigh := high
        londonLow := low
        londonHighBar := bar_index
        londonLowBar := bar_index
        londonStartBar := bar_index
        londonBuilding := true
        if showLondonBox and showLondon
            box.delete(currentLondonBox)
            currentLondonBox := box.new(bar_index, high, bar_index, low, border_color=londonColor, bgcolor=londonBoxColor, border_width=1)
    else
        if high > londonHigh
            londonHigh := high
            londonHighBar := bar_index
        if low < londonLow
            londonLow := low
            londonLowBar := bar_index
        if showLondonBox and showLondon and not na(currentLondonBox)
            box.set_top(currentLondonBox, londonHigh)
            box.set_bottom(currentLondonBox, londonLow)
            box.set_right(currentLondonBox, bar_index)

if not inLondonSession and inLondonSession[1] and londonBuilding
    londonBuilding := false
    currentLondonHigh := londonHigh
    currentLondonLow := londonLow
    currentLondonMid := (londonHigh + londonLow) / 2
    if showLondon and londonHistory > 0 and not na(londonHigh)
        hiLine = line.new(londonHighBar, londonHigh, bar_index + 100, londonHigh, color=londonColor, style=getLineStyle(), width=londonLineWidth)
        loLine = line.new(londonLowBar, londonLow, bar_index + 100, londonLow, color=londonColor, style=getLineStyle(), width=londonLineWidth)
        midLine = showLondonMid ? line.new(londonStartBar, currentLondonMid, bar_index + 100, currentLondonMid, color=color.new(londonColor, 50), style=line.style_dotted, width=math.max(1, londonLineWidth - 1)) : na
        hiLabel = showLabels ? label.new(bar_index + 102, londonHigh, "LDN H", style=label.style_none, textcolor=londonColor, size=getLabelSize()) : na
        loLabel = showLabels ? label.new(bar_index + 102, londonLow, "LDN L", style=label.style_none, textcolor=londonColor, size=getLabelSize()) : na
        midLabel = showLabels and showLondonMid ? label.new(bar_index + 102, currentLondonMid, "LDN M", style=label.style_none, textcolor=color.new(londonColor, 50), size=getLabelSize()) : na
        newLevel = levelData.new(londonHigh, londonLow, currentLondonMid, londonStartBar, londonHighBar, londonLowBar, hiLine, loLine, midLine, hiLabel, loLabel, midLabel, currentLondonBox)
        array.unshift(londonArray, newLevel)
        if array.size(londonArray) > londonHistory
            old = array.pop(londonArray)
            line.delete(old.hiLine)
            line.delete(old.loLine)
            line.delete(old.midLine)
            label.delete(old.hiLabel)
            label.delete(old.loLabel)
            label.delete(old.midLabel)
            box.delete(old.sessionBox)

if array.size(londonArray) > 0
    for i = 0 to array.size(londonArray) - 1
        lvl = array.get(londonArray, i)
        extendBars = bar_index + 20
        line.set_x2(lvl.hiLine, extendBars)
        line.set_x2(lvl.loLine, extendBars)
        if showLondonMid and not na(lvl.midLine)
            line.set_x2(lvl.midLine, extendBars)
        if i == 0 and showLabels
            label.set_x(lvl.hiLabel, extendBars + 2)
            label.set_x(lvl.loLabel, extendBars + 2)
            if showLondonMid and not na(lvl.midLabel)
                label.set_x(lvl.midLabel, extendBars + 2)
        else
            label.delete(lvl.hiLabel)
            label.delete(lvl.loLabel)
            label.delete(lvl.midLabel)
            lvl.hiLabel := na
            lvl.loLabel := na
            lvl.midLabel := na

// ══════════════════════════════════════════════════════════════════════════════
// FAIR VALUE GAPS
// ══════════════════════════════════════════════════════════════════════════════

if showFVG
    threshold = autoThreshold ? ta.cum((high - low) / low) / bar_index : fvgThreshold / 100
    bullFVG = low > high[2] and close[1] > high[2] and (low - high[2]) / high[2] > threshold
    bearFVG = high < low[2] and close[1] < low[2] and (low[2] - high) / high > threshold

    if bullFVG
        newBox = box.new(bar_index - 2, low, bar_index + fvgExtend, high[2], na, bgcolor=bullFVGColor)
        newFVG = fvgData.new(low, high[2], true, bar_index, newBox)
        array.unshift(fvgArray, newFVG)
    if bearFVG
        newBox = box.new(bar_index - 2, low[2], bar_index + fvgExtend, high, na, bgcolor=bearFVGColor)
        newFVG = fvgData.new(low[2], high, false, bar_index, newBox)
        array.unshift(fvgArray, newFVG)

    if fvgMitigation and array.size(fvgArray) > 0
        for i = array.size(fvgArray) - 1 to 0
            f = array.get(fvgArray, i)
            mitigated = f.isBull ? close < f.bottom : close > f.top
            if mitigated
                box.delete(f.area)
                array.remove(fvgArray, i)
    while array.size(fvgArray) > 100
        old = array.pop(fvgArray)
        box.delete(old.area)

// ══════════════════════════════════════════════════════════════════════════════
// DASHBOARD
// ══════════════════════════════════════════════════════════════════════════════

if showDashboard
    tablePos = switch dashPosition
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        => position.bottom_left
    var table dash = table.new(tablePos, 3, 6, bgcolor=dashBgColor, border_width=1, border_color=dashBorderColor)
    if barstate.islast
        table.cell(dash, 0, 0, "HTF BIAS", text_color=dashHeaderText, text_size=getDashSize(), bgcolor=dashHeaderBg)
        table.cell(dash, 1, 0, "Structure", text_color=dashHeaderText, text_size=getDashSize(), bgcolor=dashHeaderBg)
        table.cell(dash, 2, 0, "Bias", text_color=dashHeaderText, text_size=getDashSize(), bgcolor=dashHeaderBg)
        table.cell(dash, 0, 1, formatTF(htf1), text_color=dashLabelColor, text_size=getDashSize())
        table.cell(dash, 1, 1, htf1StructureText, text_color=htf1BiasColor, text_size=getDashSize())
        table.cell(dash, 2, 1, htf1BiasText, text_color=htf1BiasColor, text_size=getDashSize())
        table.cell(dash, 0, 2, formatTF(htf2), text_color=dashLabelColor, text_size=getDashSize())
        table.cell(dash, 1, 2, htf2StructureText, text_color=htf2BiasColor, text_size=getDashSize())
        table.cell(dash, 2, 2, htf2BiasText, text_color=htf2BiasColor, text_size=getDashSize())
        orbText = orbComplete ? str.tostring(currentORBHigh, format.mintick) + " / " + str.tostring(currentORBLow, format.mintick) : "Building..."
        table.cell(dash, 0, 3, "ORB (" + orbDisplayTime + ")", text_color=dashLabelColor, text_size=getDashSize())
        table.cell(dash, 1, 3, orbText, text_color=orbHighColor, text_size=getDashSize())
        table.merge_cells(dash, 1, 3, 2, 3)
        modeText = sessionMode == "Kill Zones" ? "Kill Zones" : "Full Sessions"
        table.cell(dash, 0, 4, "Mode", text_color=dashLabelColor, text_size=getDashSize())
        table.cell(dash, 1, 4, modeText, text_color=dashLabelColor, text_size=getDashSize())
        table.merge_cells(dash, 1, 4, 2, 4)
        pdSourceText = pdSource == "RTH Only" ? "RTH (9:30-4:00)" : "Full (6pm-5pm)"
        table.cell(dash, 0, 5, "PDH/PDL", text_color=dashLabelColor, text_size=getDashSize())
        table.cell(dash, 1, 5, pdSourceText, text_color=pdhColor, text_size=getDashSize())
        table.merge_cells(dash, 1, 5, 2, 5)
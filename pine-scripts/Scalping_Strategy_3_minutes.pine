// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © traderschatroom88

//@version=5

VERSION = 'v6_1_23'// 2023.10.13

strategy(
 'XXX',
 shorttitle = 'XXX ' + VERSION,
 overlay = true,
 explicit_plot_zorder = true,
 pyramiding = 0,
 default_qty_type = strategy.percent_of_equity,
 default_qty_value = 10,
 calc_on_every_tick = false,
 process_orders_on_close = true)

// Project #827
// Actual version: @gu5tavo71 for Riccardo (@rikyfx for PineScripters Jobs)
// This script reuses open source code from another authors:
// @PineCoders, Built-in Library, and Community Scripts
// Disclaimer: I am not a financial advisor.
// For purpose educate only. Use at your own risk.

G_SCRIPT01 = '■ ' + 'SAIYAN OCC'

//#region ———— <↓↓↓ G_SCRIPT01 ↓↓↓> {

// === INPUTS ===

res = input.timeframe('15', 'TIMEFRAME', group ="NON REPAINT")
useRes = input(true, 'Use Alternate Signals')
intRes = input(8, 'Multiplier for Alernate Signals')
basisType = input.string('ALMA', 'MA Type: ', options=['TEMA', 'HullMA', 'ALMA'])
basisLen = input.int(2, 'MA Period', minval=1)
offsetSigma = input.int(5, 'Offset for LSMA / Sigma for ALMA', minval=0)
offsetALMA = input.float(0.85, 'Offset for ALMA', minval=0, step=0.01)
scolor = input(false, 'Show coloured Bars to indicate Trend?')
delayOffset = input.int(0, 'Delay Open/Close MA', minval=0, step=1, tooltip = 'Forces Non-Repainting')
tradeType = input.string('BOTH', 'What trades should be taken : ', options = ['LONG', 'SHORT', 'BOTH', 'NONE'])

//=== /INPUTS ===

h = input(false, 'Signals for Heikin Ashi Candles')

//INDICATOR SETTINGS
swing_length = input.int(10, 'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, 'History To Keep', minval = 5, maxval = 50)
box_width = input.float(2.5, 'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//INDICATOR VISUAL SETTINGS
show_zigzag = input.bool(false, 'Show Zig Zag', group = 'Visual Settings', inline = '1')
show_price_action_labels = input.bool(false, 'Show Price Action Labels', group = 'Visual Settings', inline = '2')
supply_color = input.color(#00000000, 'Supply', group = 'Visual Settings', inline = '3')
supply_outline_color = input.color(#00000000, 'Outline', group = 'Visual Settings', inline = '3')
demand_color = input.color(#00000000, 'Demand', group = 'Visual Settings', inline = '4')
demand_outline_color = input.color(#00000000, 'Outline', group = 'Visual Settings', inline = '4')
bos_label_color = input.color(#00000000, 'BOS Label', group = 'Visual Settings', inline = '5')
poi_label_color = input.color(#00000000, 'POI Label', group = 'Visual Settings', inline = '7')
poi_border_color = input.color(#00000000, 'POI border', group = 'Visual Settings', inline = '7')
swing_type_color = input.color(#00000000, 'Price Action Label', group = 'Visual Settings', inline = '8')
zigzag_color = input.color(#00000000, 'Zig Zag', group = 'Visual Settings', inline = '9')

//END SETTINGS

//FUNCTIONS

// FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

// FUNCTION SWING H & L LABELS
f_sh_sl_labels(array, swing_type) =>
    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
        label.new(
            bar_index - swing_length, array.get(array,0),
            text = label_text,
            style = label.style_label_down,
            textcolor = swing_type_color,
            color = swing_type_color,
            size = size.tiny)
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'
        label.new(
            bar_index - swing_length, array.get(array,0),
            text = label_text,
            style = label.style_label_up,
            textcolor = swing_type_color,
            color = swing_type_color,
            size = size.tiny)

// FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atrValue) =>
    atr_threshold = atrValue * 2
    okay_to_draw = true
    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2
        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold
        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else
            okay_to_draw := true
    okay_to_draw

// FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atrValue) =>
    atr_buffer = atrValue * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index
    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00
    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
    okay_to_draw = f_check_overlapping(poi, box_array, atrValue)
    // okay_to_draw = true

    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new(
            left = box_left, top = box_top, right = box_right, bottom = box_bottom,
            border_color = supply_outline_color, bgcolor = supply_color,
            extend = extend.right,
            text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small,
            xloc = xloc.bar_index))
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new(
            left = box_left, top = poi, right = box_right, bottom = poi,
            border_color = poi_border_color, bgcolor = poi_border_color,
            extend = extend.right,
            text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small,
            xloc = xloc.bar_index))
    else if box_type == -1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new(
            left = box_left, top = box_top, right = box_right, bottom = box_bottom,
            border_color = demand_outline_color, bgcolor = demand_color,
            extend = extend.right,
            text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small,
            xloc = xloc.bar_index))
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new(
            left = box_left, top = poi, right = box_right, bottom = poi,
            border_color = poi_border_color, bgcolor = poi_border_color,
            extend = extend.right,
            text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small,
            xloc = xloc.bar_index))

// FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>
    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            // if ta.crossover(close, level_to_break)
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            // if ta.crossunder(close, level_to_break)
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

// FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)

//END FUNCTIONS

//CALCULATIONS

stratRes = timeframe.ismonthly ? str.tostring(timeframe.multiplier * intRes, '###M') : timeframe.isweekly ? str.tostring(timeframe.multiplier * intRes, '###W') : timeframe.isdaily ? str.tostring(timeframe.multiplier * intRes, '###D') : timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes, '####') : '60'

src = h ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead = barmerge.lookahead_off) : close

// CALCULATE ATR
atrValue = ta.atr(50)

// CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)

// ARRAYS FOR SWING H/L & BN
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)
var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)

// ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

// ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

// ARRAYS FOR BOS
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)

//END CALCULATIONS

// NEW SWING HIGH
if not na(swing_high)
    //MANAGE SWING HIGH VALUES
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atrValue)

// NEW SWING LOW
else if not na(swing_low)
    //MANAGE SWING LOW VALUES
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atrValue)

f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)
f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

//#endregion }

// ——————————— <↑↑↑ G_SCRIPT01 ↑↑↑>

//<triggers>
lxTrigger = false
sxTrigger = false
leTrigger = ta.crossover (closeSeriesAlt, openSeriesAlt)
seTrigger = ta.crossunder(closeSeriesAlt, openSeriesAlt)

G_RISK = '■ ' + 'Risk Management'

//#region ———— <↓↓↓ G_RISK ↓↓↓> {

// ——————————— <constant_declarations>

//Tooltip
T_LVL = '(%) Exit Level'
T_QTY = '(%) Adjust trade exit volume'
T_MSG = 'Paste JSON message for your bot'

//Webhook Message
O_LEMSG = 'Long Entry'
O_LXMSGSL = 'Long SL'
O_LXMSGTP1 = 'Long TP1'
O_LXMSGTP2 = 'Long TP2'
O_LXMSGTP3 = 'Long TP3'
O_LXMSG = 'Long Exit'
O_SEMSG = 'Short Entry'
O_SXMSGSL = 'Short SL'
O_SXMSGA = 'Short TP1'
O_SXMSGB = 'Short TP2'
O_SXMSGC = 'Short TP3'
O_SXMSGX = 'Short Exit'

// ——————————— <input>

i_lxLvlTP1 = input.float (1, 'Level TP1' , group = G_RISK, tooltip = T_LVL)
i_lxQtyTP1 = input.float (50, 'Qty TP1' , group = G_RISK, tooltip = T_QTY)
i_lxLvlTP2 = input.float (1.5, 'Level TP2' , group = G_RISK, tooltip = T_LVL)
i_lxQtyTP2 = input.float (30, 'Qty TP2' , group = G_RISK, tooltip = T_QTY)
i_lxLvlTP3 = input.float (2, 'Level TP3' , group = G_RISK, tooltip = T_LVL)
i_lxQtyTP3 = input.float (20, 'Qty TP3' , group = G_RISK, tooltip = T_QTY)
i_lxLvlSL = input.float (0.5, 'Stop Loss' , group = G_RISK, tooltip = T_LVL)

i_sxLvlTP1 = i_lxLvlTP1
i_sxQtyTP1 = i_lxQtyTP1
i_sxLvlTP2 = i_lxLvlTP2
i_sxQtyTP2 = i_lxQtyTP2
i_sxLvlTP3 = i_lxLvlTP3
i_sxQtyTP3 = i_lxQtyTP3
i_sxLvlSL = i_lxLvlSL

G_MSG = '■ ' + 'Webhook Message'

i_leMsg = input.string (O_LEMSG ,'Long Entry' , group = G_MSG, tooltip = T_MSG)
i_lxMsgSL = input.string (O_LXMSGSL ,'Long SL' , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP1 = input.string (O_LXMSGTP1,'Long TP1' , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP2 = input.string (O_LXMSGTP2,'Long TP2' , group = G_MSG, tooltip = T_MSG)
i_lxMsgTP3 = input.string (O_LXMSGTP3,'Long TP3' , group = G_MSG, tooltip = T_MSG)
i_lxMsg = input.string (O_LXMSG ,'Long Exit' , group = G_MSG, tooltip = T_MSG)

i_seMsg = input.string (O_SEMSG ,'Short Entry' , group = G_MSG, tooltip = T_MSG)
i_sxMsgSL = input.string (O_SXMSGSL ,'Short SL' , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP1 = input.string (O_SXMSGA ,'Short TP1' , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP2 = input.string (O_SXMSGB ,'Short TP2' , group = G_MSG, tooltip = T_MSG)
i_sxMsgTP3 = input.string (O_SXMSGC ,'Short TP3' , group = G_MSG, tooltip = T_MSG)
i_sxMsg = input.string (O_SXMSGX ,'Short Exit' , group = G_MSG, tooltip = T_MSG)

i_src = close

G_DISPLAY = 'Display'

//<display>
i_alertOn = input.bool (true, 'Alert Labels On/Off' , group = G_DISPLAY)
i_barColOn = input.bool (true, 'Bar Color On/Off' , group = G_DISPLAY)

// ——————————— <function_declarations>

// @function Calculate the Take Profit line, and the crossover or crossunder
f_tp(_condition, _conditionValue, _leTrigger, _seTrigger, _src, _lxLvlTP, _sxLvlTP)=>
    var float _tpLine = 0.0
    _topLvl = _src + (_src * (_lxLvlTP / 100))
    _botLvl = _src - (_src * (_sxLvlTP / 100))
    _tpLine := _condition[1] != _conditionValue and _leTrigger ? _topLvl : _condition[1] != -_conditionValue and _seTrigger ? _botLvl : nz(_tpLine[1])
    [_tpLine]

// @function Similar to "ta.crossover" or "ta.crossunder"
f_cross(_scr1, _scr2, _over)=>
    _cross = _over ? _scr1 > _scr2 and _scr1[1] < _scr2[1] : _scr1 < _scr2 and _scr1[1] > _scr2[1]

// ——————————— <calculations>

//<set initial values>
var float condition = 0.0
var float slLine = 0.0
var float entryLine = 0.0

//<entry & exit orders>
entryLine := leTrigger and condition[1] <= 0.0 ? close : seTrigger and condition[1] >= 0.0 ? close : nz(entryLine[1])

//<SL>
slTopLvl = i_src + (i_src * (i_lxLvlSL / 100))
slBotLvl = i_src - (i_src * (i_sxLvlSL / 100))
slLine := condition[1] <= 0.0 and leTrigger ? slBotLvl : condition[1] >= 0.0 and seTrigger ? slTopLvl : nz(slLine[1])
slLong = f_cross(low, slLine, false)
slShort = f_cross(high, slLine, true )

//<TP1, TP2 & TP3>
[tp3Line] = f_tp(condition, 1.2,leTrigger, seTrigger, i_src, i_lxLvlTP3, i_sxLvlTP3)
[tp2Line] = f_tp(condition, 1.1,leTrigger, seTrigger, i_src, i_lxLvlTP2, i_sxLvlTP2)
[tp1Line] = f_tp(condition, 1.0,leTrigger, seTrigger, i_src, i_lxLvlTP1, i_sxLvlTP1)

tp3Long = f_cross(high, tp3Line, true )
tp3Short = f_cross(low, tp3Line, false)
tp2Long = f_cross(high, tp2Line, true )
tp2Short = f_cross(low, tp2Line, false)
tp1Long = f_cross(high, tp1Line, true )
tp1Short = f_cross(low, tp1Line, false)

switch
    leTrigger and condition[1] <= 0.0 => condition := 1.0
    seTrigger and condition[1] >= 0.0 => condition := -1.0
    tp3Long and condition[1] == 1.2 => condition := 1.3
    tp3Short and condition[1] == -1.2 => condition := -1.3
    tp2Long and condition[1] == 1.1 => condition := 1.2
    tp2Short and condition[1] == -1.1 => condition := -1.2
    tp1Long and condition[1] == 1.0 => condition := 1.1
    tp1Short and condition[1] == -1.0 => condition := -1.1
    slLong and condition[1] >= 1.0 => condition := 0.0
    slShort and condition[1] <= -1.0 => condition := 0.0
    lxTrigger and condition[1] >= 1.0 => condition := 0.0
    sxTrigger and condition[1] <= -1.0 => condition := 0.0

longE = leTrigger and condition[1] <= 0.0 and condition == 1.0
shortE = seTrigger and condition[1] >= 0.0 and condition == -1.0
longX = lxTrigger and condition[1] >= 1.0 and condition == 0.0
shortX = sxTrigger and condition[1] <= -1.0 and condition == 0.0
longSL = slLong and condition[1] >= 1.0 and condition == 0.0
shortSL = slShort and condition[1] <= -1.0 and condition == 0.0
longTP3 = tp3Long and condition[1] == 1.2 and condition == 1.3
shortTP3 = tp3Short and condition[1] == -1.2 and condition == -1.3
longTP2 = tp2Long and condition[1] == 1.1 and condition == 1.2
shortTP2 = tp2Short and condition[1] == -1.1 and condition == -1.2
longTP1 = tp1Long and condition[1] == 1.0 and condition == 1.1
shortTP1 = tp1Short and condition[1] == -1.0 and condition == -1.1

// ——————————— <strategy_calls> {

//<long orders>
if strategy.position_size <= 0 and longE and barstate.isconfirmed
    strategy.entry( 'Long', strategy.long, alert_message = i_leMsg, comment = 'LE')

if strategy.position_size > 0 and condition == 1.0
    strategy.exit( id = 'LXTP1', from_entry = 'Long', qty_percent = i_lxQtyTP1, limit = tp1Line, stop = slLine, comment_profit = 'LXTP1', comment_loss = 'SL', alert_profit = i_lxMsgTP1, alert_loss = i_lxMsgSL)

if strategy.position_size > 0 and condition == 1.1
    strategy.exit( id = 'LXTP2', from_entry = 'Long', qty_percent = i_lxQtyTP2, limit = tp2Line, stop = slLine, comment_profit = 'LXTP2', comment_loss = 'SL', alert_profit = i_lxMsgTP2, alert_loss = i_lxMsgSL)

if strategy.position_size > 0 and condition == 1.2
    strategy.exit( id = 'LXTP3', from_entry = 'Long', qty_percent = i_lxQtyTP3, limit = tp3Line, stop = slLine, comment_profit = 'LXTP3', comment_loss = 'SL', alert_profit = i_lxMsgTP3, alert_loss = i_lxMsgSL)

if longX
    strategy.close( 'Long', alert_message = i_lxMsg, comment = 'LX')

//<short orders>
if strategy.position_size >= 0 and shortE and barstate.isconfirmed
    strategy.entry( 'Short', strategy.short, alert_message = i_leMsg, comment = 'SE')

if strategy.position_size < 0 and condition == -1.0
    strategy.exit( id = 'SXTP1', from_entry = 'Short', qty_percent = i_sxQtyTP1, limit = tp1Line, stop = slLine, comment_profit = 'SXTP1', comment_loss = 'SL', alert_profit = i_sxMsgTP1, alert_loss = i_sxMsgSL)

if strategy.position_size < 0 and condition == -1.1
    strategy.exit( id = 'SXTP2', from_entry = 'Short', qty_percent = i_sxQtyTP2, limit = tp2Line, stop = slLine, comment_profit = 'SXTP2', comment_loss = 'SL', alert_profit = i_sxMsgTP2, alert_loss = i_sxMsgSL)

if strategy.position_size < 0 and condition == -1.2
    strategy.exit( id = 'SXTP3', from_entry = 'Short', qty_percent = i_sxQtyTP3, limit = tp3Line, stop = slLine, comment_profit = 'SXTP3', comment_loss = 'SL', alert_profit = i_sxMsgTP3, alert_loss = i_sxMsgSL)

if shortX
    strategy.close( 'Short', alert_message = i_sxMsg, comment = 'SX')

// ——————————— <visuals>

c_tp = leTrigger or seTrigger ? na : condition == 0.0 ? na : color.green
c_entry = leTrigger or seTrigger ? na : condition == 0.0 ? na : color.blue
c_sl = leTrigger or seTrigger ? na : condition == 0.0 ? na : color.red

p_tp1Line = plot ( condition == 1.0 or condition == -1.0 ? tp1Line : na, title = "TP Line 1", color = c_tp, linewidth = 1, style = plot.style_linebr)
p_tp2Line = plot ( condition == 1.0 or condition == -1.0 or condition == 1.1 or condition == -1.1 ? tp2Line : na, title = "TP Line 2", color = c_tp, linewidth = 1, style = plot.style_linebr)
p_tp3Line = plot ( condition == 1.0 or condition == -1.0 or condition == 1.1 or condition == -1.1 or condition == 1.2 or condition == -1.2 ? tp3Line : na, title = "TP Line 3", color = c_tp, linewidth = 1, style = plot.style_linebr)
p_entryLine = plot ( condition >= 1.0 or condition <= -1.0 ? entryLine : na, title = "Entry Line", color = c_entry, linewidth = 1, style = plot.style_linebr)
p_slLine = plot ( condition == 1.0 or condition == -1.0 or condition == 1.1 or condition == -1.1 or condition == 1.2 or condition == -1.2 ? slLine : na, title = "SL Line", color = c_sl, linewidth = 1, style = plot.style_linebr)

fill( p_tp3Line, p_entryLine, color = leTrigger or seTrigger ? na :color.new(color.green, 90))
fill( p_entryLine, p_slLine, color = leTrigger or seTrigger ? na :color.new(color.red, 90))

//<alerts labels>
plotshape( i_alertOn and longE, title = 'Long', text = 'Long', textcolor = color.white, color = color.green, style = shape.labelup, size = size.tiny, location = location.belowbar)
plotshape( i_alertOn and shortE, title = 'Short', text = 'Short', textcolor = color.white, color = color.red, style = shape.labeldown, size = size.tiny, location = location.abovebar)
plotshape( i_alertOn and (longX or shortX) ? close : na, title = 'Close', text = 'Close', textcolor = color.white, color = color.gray, style = shape.labelup, size = size.tiny, location = location.absolute)

l_tp = i_alertOn and (longTP1 or shortTP1) ? close : na

plotshape( l_tp, title = "TP1 Cross", text = "TP1", textcolor = color.white, color = color.olive, style = shape.labelup, size = size.tiny, location = location.absolute)
plotshape( i_alertOn and (longTP2 or shortTP2) ? close : na, title = "TP2 Cross", text = "TP2", textcolor = color.white, color = color.olive, style = shape.labelup, size = size.tiny, location = location.absolute)
plotshape( i_alertOn and (longTP3 or shortTP3) ? close : na, title = "TP3 Cross", text = "TP3", textcolor = color.white, color = color.olive, style = shape.labelup, size = size.tiny, location = location.absolute)
plotshape( i_alertOn and (longSL or shortSL) ? close : na, title = "SL Cross", text = "SL", textcolor = color.white, color = color.maroon, style = shape.labelup, size = size.tiny, location = location.absolute)

//<debug>
plot( na, title = "─── <debug> ───", editable = false, display = display.data_window)
plot( condition, title = "condition", editable = false, display = display.data_window)
plot( strategy.position_size * 100, title = ".position_size", editable = false, display = display.data_window)

//#endregion }

// ——————————— <↑↑↑ G_RISK ↑↑↑>
